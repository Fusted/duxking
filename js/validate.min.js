/**
 * @license
 jQuery Validation Plugin - v1.19.1 - 6/15/2019
 https://jqueryvalidation.org/
 Copyright (c) 2019 JÃ¶rn Zaefferer; Licensed MIT */
 'use strict';
 !function(factory) {
   if ("function" == typeof define && define.amd) {
     define(["jquery"], factory);
   } else {
     if ("object" == typeof module && module.exports) {
       module.exports = factory(require("jquery"));
     } else {
       factory(jQuery);
     }
   }
 }(function($) {
   $.extend($.fn, {
     validate : function(options) {
       if (!this.length) {
         return void(options && options.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing."));
       }
       var validator = $.data(this[0], "validator");
       return validator ? validator : (this.attr("novalidate", "novalidate"), validator = new $.validator(options, this[0]), $.data(this[0], "validator", validator), validator.settings.onsubmit && (this.on("click.validate", ":submit", function(event) {
         validator.submitButton = event.currentTarget;
         if ($(this).hasClass("cancel")) {
           /** @type {boolean} */
           validator.cancelSubmit = true;
         }
         if (void 0 !== $(this).attr("formnovalidate")) {
           /** @type {boolean} */
           validator.cancelSubmit = true;
         }
       }), this.on("submit.validate", function(event) {
         /**
          * @return {?}
          */
         function handle() {
           var isArr;
           var result;
           return validator.submitButton && (validator.settings.submitHandler || validator.formSubmitted) && (isArr = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val($(validator.submitButton).val()).appendTo(validator.currentForm)), !(validator.settings.submitHandler && !validator.settings.debug) || (result = validator.settings.submitHandler.call(validator, validator.currentForm, event), isArr && isArr.remove(), void 0 !== result && result);
         }
         return validator.settings.debug && event.preventDefault(), validator.cancelSubmit ? (validator.cancelSubmit = false, handle()) : validator.form() ? validator.pendingRequest ? (validator.formSubmitted = true, false) : handle() : (validator.focusInvalid(), false);
       })), validator);
     },
     valid : function() {
       var b;
       var validator;
       var errorList;
       return $(this[0]).is("form") ? b = this.validate().form() : (errorList = [], b = true, validator = $(this[0].form).validate(), this.each(function() {
         b = validator.element(this) && b;
         if (!b) {
           errorList = errorList.concat(validator.errorList);
         }
       }), validator.errorList = errorList), b;
     },
     rules : function(command, argument) {
       var settings;
       var staticRules;
       var obj;
       var data;
       var param;
       var dhtmlx;
       var element = this[0];
       /** @type {boolean} */
       var k = "undefined" != typeof this.attr("contenteditable") && "false" !== this.attr("contenteditable");
       if (null != element && (!element.form && k && (element.form = this.closest("form")[0], element.name = this.attr("name")), null != element.form)) {
         if (command) {
           switch(settings = $.data(element.form, "validator").settings, staticRules = settings.rules, obj = $.validator.staticRules(element), command) {
             case "add":
               $.extend(obj, $.validator.normalizeRule(argument));
               delete obj.messages;
               staticRules[element.name] = obj;
               if (argument.messages) {
                 settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
               }
               break;
             case "remove":
               return argument ? (dhtmlx = {}, $.each(argument.split(/\s/), function(mmCoreSecondsYear, a) {
                 dhtmlx[a] = obj[a];
                 delete obj[a];
               }), dhtmlx) : (delete staticRules[element.name], obj);
           }
         }
         return data = $.validator.normalizeRules($.extend({}, $.validator.classRules(element), $.validator.attributeRules(element), $.validator.dataRules(element), $.validator.staticRules(element)), element), data.required && (param = data.required, delete data.required, data = $.extend({
           required : param
         }, data)), data.remote && (param = data.remote, delete data.remote, data = $.extend(data, {
           remote : param
         })), data;
       }
     }
   });
   $.extend($.expr.pseudos || $.expr[":"], {
     blank : function(a) {
       return !$.trim("" + $(a).val());
     },
     filled : function(a) {
       var x = $(a).val();
       return null !== x && !!$.trim("" + x);
     },
     unchecked : function(a) {
       return !$(a).prop("checked");
     }
   });
   /**
    * @param {?} options
    * @param {string} form
    * @return {undefined}
    */
   $.validator = function(options, form) {
     this.settings = $.extend(true, {}, $.validator.defaults, options);
     /** @type {string} */
     this.currentForm = form;
     this.init();
   };
   /**
    * @param {string} e
    * @param {number} results
    * @return {?}
    */
   $.validator.format = function(e, results) {
     return 1 === arguments.length ? function() {
       var s = $.makeArray(arguments);
       return s.unshift(e), $.validator.format.apply(this, s);
     } : void 0 === results ? e : (arguments.length > 2 && results.constructor !== Array && (results = $.makeArray(arguments).slice(1)), results.constructor !== Array && (results = [results]), $.each(results, function(a, canCreateDiscussions) {
       e = e.replace(new RegExp("\\{" + a + "\\}", "g"), function() {
         return canCreateDiscussions;
       });
     }), e);
   };
   $.extend($.validator, {
     defaults : {
       messages : {},
       groups : {},
       rules : {},
       errorClass : "error",
       pendingClass : "pending",
       validClass : "valid",
       errorElement : "label",
       focusCleanup : false,
       focusInvalid : true,
       errorContainer : $([]),
       errorLabelContainer : $([]),
       onsubmit : true,
       ignore : ":hidden",
       ignoreTitle : false,
       onfocusin : function(element) {
         /** @type {!Object} */
         this.lastActive = element;
         if (this.settings.focusCleanup) {
           if (this.settings.unhighlight) {
             this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
           }
           this.hideThese(this.errorsFor(element));
         }
       },
       onfocusout : function(element) {
         if (!(this.checkable(element) || !(element.name in this.submitted) && this.optional(element))) {
           this.element(element);
         }
       },
       onkeyup : function(element, event) {
         /** @type {!Array} */
         var compareTerms = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];
         if (!(9 === event.which && "" === this.elementValue(element) || $.inArray(event.keyCode, compareTerms) !== -1)) {
           if (element.name in this.submitted || element.name in this.invalid) {
             this.element(element);
           }
         }
       },
       onclick : function(element) {
         if (element.name in this.submitted) {
           this.element(element);
         } else {
           if (element.parentNode.name in this.submitted) {
             this.element(element.parentNode);
           }
         }
       },
       highlight : function(elem, c, d) {
         if ("radio" === elem.type) {
           this.findByName(elem.name).addClass(c).removeClass(d);
         } else {
           $(elem).addClass(c).removeClass(d);
         }
       },
       unhighlight : function(element, errorClass, validClass) {
         if ("radio" === element.type) {
           this.findByName(element.name).removeClass(errorClass).addClass(validClass);
         } else {
           $(element).removeClass(errorClass).addClass(validClass);
         }
       }
     },
     setDefaults : function(settings) {
       $.extend($.validator.defaults, settings);
     },
     messages : {
       required : "This field is required.",
       remote : "Please fix this field.",
       email : "Please enter a valid email address.",
       url : "Please enter a valid URL.",
       date : "Please enter a valid date.",
       dateISO : "Please enter a valid date (ISO).",
       number : "Please enter a valid number.",
       digits : "Please enter only digits.",
       equalTo : "Please enter the same value again.",
       maxlength : $.validator.format("Please enter no more than {0} characters."),
       minlength : $.validator.format("Please enter at least {0} characters."),
       rangelength : $.validator.format("Please enter a value between {0} and {1} characters long."),
       range : $.validator.format("Please enter a value between {0} and {1}."),
       max : $.validator.format("Please enter a value less than or equal to {0}."),
       min : $.validator.format("Please enter a value greater than or equal to {0}."),
       step : $.validator.format("Please enter a multiple of {0}.")
     },
     autoCreateRanges : false,
     prototype : {
       init : function() {
         /**
          * @param {!Object} event
          * @return {undefined}
          */
         function delegate(event) {
           /** @type {boolean} */
           var c = "undefined" != typeof $(this).attr("contenteditable") && "false" !== $(this).attr("contenteditable");
           if (!this.form && c && (this.form = $(this).closest("form")[0], this.name = $(this).attr("name")), form === this.form) {
             var validator = $.data(this.form, "validator");
             var eventType = "on" + event.type.replace(/^validate/, "");
             var settings = validator.settings;
             if (settings[eventType] && !$(this).is(settings.ignore)) {
               settings[eventType].call(validator, this, event);
             }
           }
         }
         this.labelContainer = $(this.settings.errorLabelContainer);
         this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
         this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
         this.submitted = {};
         this.valueCache = {};
         /** @type {number} */
         this.pendingRequest = 0;
         this.pending = {};
         this.invalid = {};
         this.reset();
         var rules;
         var form = this.currentForm;
         var groups = this.groups = {};
         $.each(this.settings.groups, function($this, a) {
           if ("string" == typeof a) {
             /** @type {!Array<string>} */
             a = a.split(/\s/);
           }
           $.each(a, function(a, i) {
             groups[i] = $this;
           });
         });
         rules = this.settings.rules;
         $.each(rules, function(name, value) {
           rules[name] = $.validator.normalizeRule(value);
         });
         $(this.currentForm).on("focusin.validate focusout.validate keyup.validate", ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate).on("click.validate", "select, option, [type='radio'], [type='checkbox']", 
         delegate);
         if (this.settings.invalidHandler) {
           $(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler);
         }
       },
       form : function() {
         return this.checkForm(), $.extend(this.submitted, this.errorMap), this.invalid = $.extend({}, this.errorMap), this.valid() || $(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid();
       },
       checkForm : function() {
         this.prepareForm();
         /** @type {number} */
         var i = 0;
         var elements = this.currentElements = this.elements();
         for (; elements[i]; i++) {
           this.check(elements[i]);
         }
         return this.valid();
       },
       element : function(element) {
         var rs;
         var group;
         var cleanElement = this.clean(element);
         var checkElement = this.validationTargetFor(cleanElement);
         var v = this;
         /** @type {boolean} */
         var result = true;
         return void 0 === checkElement ? delete this.invalid[cleanElement.name] : (this.prepareElement(checkElement), this.currentElements = $(checkElement), group = this.groups[checkElement.name], group && $.each(this.groups, function(name, testgroup) {
           if (testgroup === group && name !== checkElement.name) {
             cleanElement = v.validationTargetFor(v.clean(v.findByName(name)));
             if (cleanElement && cleanElement.name in v.invalid) {
               v.currentElements.push(cleanElement);
               result = v.check(cleanElement) && result;
             }
           }
         }), rs = this.check(checkElement) !== false, result = result && rs, rs ? this.invalid[checkElement.name] = false : this.invalid[checkElement.name] = true, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), $(element).attr("aria-invalid", !rs)), result;
       },
       showErrors : function(errors) {
         if (errors) {
           var windowsStorage = this;
           $.extend(this.errorMap, errors);
           this.errorList = $.map(this.errorMap, function(notMessage, target) {
             return {
               message : notMessage,
               element : windowsStorage.findByName(target)[0]
             };
           });
           this.successList = $.grep(this.successList, function(element) {
             return !(element.name in errors);
           });
         }
         if (this.settings.showErrors) {
           this.settings.showErrors.call(this, this.errorMap, this.errorList);
         } else {
           this.defaultShowErrors();
         }
       },
       resetForm : function() {
         if ($.fn.resetForm) {
           $(this.currentForm).resetForm();
         }
         this.invalid = {};
         this.submitted = {};
         this.prepareForm();
         this.hideErrors();
         var elements = this.elements().removeData("previousValue").removeAttr("aria-invalid");
         this.resetElements(elements);
       },
       resetElements : function(elements) {
         var i;
         if (this.settings.unhighlight) {
           /** @type {number} */
           i = 0;
           for (; elements[i]; i++) {
             this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, "");
             this.findByName(elements[i].name).removeClass(this.settings.validClass);
           }
         } else {
           elements.removeClass(this.settings.errorClass).removeClass(this.settings.validClass);
         }
       },
       numberOfInvalids : function() {
         return this.objectLength(this.invalid);
       },
       objectLength : function(o) {
         var sProp;
         /** @type {number} */
         var count = 0;
         for (sProp in o) {
           if (void 0 !== o[sProp] && null !== o[sProp] && o[sProp] !== false) {
             count++;
           }
         }
         return count;
       },
       hideErrors : function() {
         this.hideThese(this.toHide);
       },
       hideThese : function(errors) {
         errors.not(this.containers).text("");
         this.addWrapper(errors).hide();
       },
       valid : function() {
         return 0 === this.size();
       },
       size : function() {
         return this.errorList.length;
       },
       focusInvalid : function() {
         if (this.settings.focusInvalid) {
           try {
             $(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").trigger("focus").trigger("focusin");
           } catch (b) {
           }
         }
       },
       findLastActive : function() {
         var lastActive = this.lastActive;
         return lastActive && 1 === $.grep(this.errorList, function(a) {
           return a.element.name === lastActive.name;
         }).length && lastActive;
       },
       elements : function() {
         var validator = this;
         var activeEngines = {};
         return $(this.currentForm).find("input, select, textarea, [contenteditable]").not(":submit, :reset, :image, :disabled").not(this.settings.ignore).filter(function() {
           var name = this.name || $(this).attr("name");
           /** @type {boolean} */
           var e = "undefined" != typeof $(this).attr("contenteditable") && "false" !== $(this).attr("contenteditable");
           return !name && validator.settings.debug && window.console && console.error("%o has no name assigned", this), e && (this.form = $(this).closest("form")[0], this.name = name), this.form === validator.currentForm && (!(name in activeEngines || !validator.objectLength($(this).rules())) && (activeEngines[name] = true, true));
         });
       },
       clean : function(context) {
         return $(context)[0];
       },
       errors : function() {
         var conid = this.settings.errorClass.split(" ").join(".");
         return $(this.settings.errorElement + "." + conid, this.errorContext);
       },
       resetInternals : function() {
         /** @type {!Array} */
         this.successList = [];
         /** @type {!Array} */
         this.errorList = [];
         this.errorMap = {};
         this.toShow = $([]);
         this.toHide = $([]);
       },
       reset : function() {
         this.resetInternals();
         this.currentElements = $([]);
       },
       prepareForm : function() {
         this.reset();
         this.toHide = this.errors().add(this.containers);
       },
       prepareElement : function(element) {
         this.reset();
         this.toHide = this.errorsFor(element);
       },
       elementValue : function(element) {
         var n;
         var p;
         var $element = $(element);
         var type = element.type;
         /** @type {boolean} */
         var complete = "undefined" != typeof $element.attr("contenteditable") && "false" !== $element.attr("contenteditable");
         return "radio" === type || "checkbox" === type ? this.findByName(element.name).filter(":checked").val() : "number" === type && "undefined" != typeof element.validity ? element.validity.badInput ? "NaN" : $element.val() : (n = complete ? $element.text() : $element.val(), "file" === type ? "C:\\fakepath\\" === n.substr(0, 12) ? n.substr(12) : (p = n.lastIndexOf("/"), p >= 0 ? n.substr(p + 1) : (p = n.lastIndexOf("\\"), p >= 0 ? n.substr(p + 1) : n)) : "string" == typeof n ? n.replace(/\r/g, 
         "") : n);
       },
       check : function(element) {
         element = this.validationTargetFor(this.clean(element));
         var message;
         var method;
         var rule;
         var normalizer;
         var rules = $(element).rules();
         var body = $.map(rules, function(a, i) {
           return i;
         }).length;
         /** @type {boolean} */
         var i = false;
         var val = this.elementValue(element);
         if ("function" == typeof rules.normalizer) {
           /** @type {!Function} */
           normalizer = rules.normalizer;
         } else {
           if ("function" == typeof this.settings.normalizer) {
             /** @type {!Function} */
             normalizer = this.settings.normalizer;
           }
         }
         if (normalizer) {
           val = normalizer.call(element, val);
           delete rules.normalizer;
         }
         for (method in rules) {
           rule = {
             method : method,
             parameters : rules[method]
           };
           try {
             if (message = $.validator.methods[method].call(this, val, element, rule.parameters), "dependency-mismatch" === message && 1 === body) {
               /** @type {boolean} */
               i = true;
               continue;
             }
             if (i = false, "pending" === message) {
               return void(this.toHide = this.toHide.not(this.errorsFor(element)));
             }
             if (!message) {
               return this.formatAndAdd(element, rule), false;
             }
           } catch (e) {
             throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e), e instanceof TypeError && (e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method."), e;
           }
         }
         if (!i) {
           return this.objectLength(rules) && this.successList.push(element), true;
         }
       },
       customDataMessage : function(element, method) {
         return $(element).data("msg" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()) || $(element).data("msg");
       },
       customMessage : function(name, method) {
         var m = this.settings.messages[name];
         return m && (m.constructor === String ? m : m[method]);
       },
       findDefined : function() {
         /** @type {number} */
         var i = 0;
         for (; i < arguments.length; i++) {
           if (void 0 !== arguments[i]) {
             return arguments[i];
           }
         }
       },
       defaultMessage : function(element, rule) {
         if ("string" == typeof rule) {
           rule = {
             method : rule
           };
         }
         var message = this.findDefined(this.customMessage(element.name, rule.method), this.customDataMessage(element, rule.method), !this.settings.ignoreTitle && element.title || void 0, $.validator.messages[rule.method], "<strong>Warning: No message defined for " + element.name + "</strong>");
         /** @type {!RegExp} */
         var theregex = /\$?\{(\d+)\}/g;
         return "function" == typeof message ? message = message.call(this, rule.parameters, element) : theregex.test(message) && (message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters)), message;
       },
       formatAndAdd : function(element, rule) {
         var message = this.defaultMessage(element, rule);
         this.errorList.push({
           message : message,
           element : element,
           method : rule.method
         });
         this.errorMap[element.name] = message;
         this.submitted[element.name] = message;
       },
       addWrapper : function(toToggle) {
         return this.settings.wrapper && (toToggle = toToggle.add(toToggle.parent(this.settings.wrapper))), toToggle;
       },
       defaultShowErrors : function() {
         var i;
         var elements;
         var error;
         /** @type {number} */
         i = 0;
         for (; this.errorList[i]; i++) {
           error = this.errorList[i];
           if (this.settings.highlight) {
             this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
           }
           this.showLabel(error.element, error.message);
         }
         if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) {
           /** @type {number} */
           i = 0;
           for (; this.successList[i]; i++) {
             this.showLabel(this.successList[i]);
           }
         }
         if (this.settings.unhighlight) {
           /** @type {number} */
           i = 0;
           elements = this.validElements();
           for (; elements[i]; i++) {
             this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
           }
         }
         this.toHide = this.toHide.not(this.toShow);
         this.hideErrors();
         this.addWrapper(this.toShow).show();
       },
       validElements : function() {
         return this.currentElements.not(this.invalidElements());
       },
       invalidElements : function() {
         return $(this.errorList).map(function() {
           return this.element;
         });
       },
       showLabel : function(element, message) {
         var place;
         var group;
         var errorID;
         var v;
         var error = this.errorsFor(element);
         var elementID = this.idOrName(element);
         var describedBy = $(element).attr("aria-describedby");
         if (error.length) {
           error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);
           error.html(message);
         } else {
           error = $("<" + this.settings.errorElement + ">").attr("id", elementID + "-error").addClass(this.settings.errorClass).html(message || "");
           place = error;
           if (this.settings.wrapper) {
             place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
           }
           if (this.labelContainer.length) {
             this.labelContainer.append(place);
           } else {
             if (this.settings.errorPlacement) {
               this.settings.errorPlacement.call(this, place, $(element));
             } else {
               place.insertAfter(element);
             }
           }
           if (error.is("label")) {
             error.attr("for", elementID);
           } else {
             if (0 === error.parents("label[for='" + this.escapeCssMeta(elementID) + "']").length) {
               errorID = error.attr("id");
               if (describedBy) {
                 if (!describedBy.match(new RegExp("\\b" + this.escapeCssMeta(errorID) + "\\b"))) {
                   /** @type {string} */
                   describedBy = describedBy + (" " + errorID);
                 }
               } else {
                 describedBy = errorID;
               }
               $(element).attr("aria-describedby", describedBy);
               group = this.groups[element.name];
               if (group) {
                 v = this;
                 $.each(v.groups, function(name, testgroup) {
                   if (testgroup === group) {
                     $("[name='" + v.escapeCssMeta(name) + "']", v.currentForm).attr("aria-describedby", error.attr("id"));
                   }
                 });
               }
             }
           }
         }
         if (!message && this.settings.success) {
           error.text("");
           if ("string" == typeof this.settings.success) {
             error.addClass(this.settings.success);
           } else {
             this.settings.success(error, element);
           }
         }
         this.toShow = this.toShow.add(error);
       },
       errorsFor : function(element) {
         var name = this.escapeCssMeta(this.idOrName(element));
         var describer = $(element).attr("aria-describedby");
         /** @type {string} */
         var excludeNone = "label[for='" + name + "'], label[for='" + name + "'] *";
         return describer && (excludeNone = excludeNone + ", #" + this.escapeCssMeta(describer).replace(/\s+/g, ", #")), this.errors().filter(excludeNone);
       },
       escapeCssMeta : function(string) {
         return string.replace(/([\\!"#$%&'()*+,.\/:;<=>?@\[\]^`{|}~])/g, "\\$1");
       },
       idOrName : function(element) {
         return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
       },
       validationTargetFor : function(element) {
         return this.checkable(element) && (element = this.findByName(element.name)), $(element).not(this.settings.ignore)[0];
       },
       checkable : function(element) {
         return /radio|checkbox/i.test(element.type);
       },
       findByName : function(name) {
         return $(this.currentForm).find("[name='" + this.escapeCssMeta(name) + "']");
       },
       getLength : function(value, element) {
         switch(element.nodeName.toLowerCase()) {
           case "select":
             return $("option:selected", element).length;
           case "input":
             if (this.checkable(element)) {
               return this.findByName(element.name).filter(":checked").length;
             }
         }
         return value.length;
       },
       depend : function(param, element) {
         return !this.dependTypes[typeof param] || this.dependTypes[typeof param](param, element);
       },
       dependTypes : {
         "boolean" : function(val) {
           return val;
         },
         string : function(elem, data) {
           return !!$(elem, data.form).length;
         },
         "function" : function(param, element) {
           return param(element);
         }
       },
       optional : function(element) {
         var val = this.elementValue(element);
         return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
       },
       startRequest : function(element) {
         if (!this.pending[element.name]) {
           this.pendingRequest++;
           $(element).addClass(this.settings.pendingClass);
           /** @type {boolean} */
           this.pending[element.name] = true;
         }
       },
       stopRequest : function(element, valid) {
         this.pendingRequest--;
         if (this.pendingRequest < 0) {
           /** @type {number} */
           this.pendingRequest = 0;
         }
         delete this.pending[element.name];
         $(element).removeClass(this.settings.pendingClass);
         if (valid && 0 === this.pendingRequest && this.formSubmitted && this.form()) {
           $(this.currentForm).submit();
           if (this.submitButton) {
             $("input:hidden[name='" + this.submitButton.name + "']", this.currentForm).remove();
           }
           /** @type {boolean} */
           this.formSubmitted = false;
         } else {
           if (!valid && 0 === this.pendingRequest && this.formSubmitted) {
             $(this.currentForm).triggerHandler("invalid-form", [this]);
             /** @type {boolean} */
             this.formSubmitted = false;
           }
         }
       },
       previousValue : function(element, method) {
         return method = "string" == typeof method && method || "remote", $.data(element, "previousValue") || $.data(element, "previousValue", {
           old : null,
           valid : true,
           message : this.defaultMessage(element, {
             method : method
           })
         });
       },
       destroy : function() {
         this.resetForm();
         $(this.currentForm).off(".validate").removeData("validator").find(".validate-equalTo-blur").off(".validate-equalTo").removeClass("validate-equalTo-blur").find(".validate-lessThan-blur").off(".validate-lessThan").removeClass("validate-lessThan-blur").find(".validate-lessThanEqual-blur").off(".validate-lessThanEqual").removeClass("validate-lessThanEqual-blur").find(".validate-greaterThanEqual-blur").off(".validate-greaterThanEqual").removeClass("validate-greaterThanEqual-blur").find(".validate-greaterThan-blur").off(".validate-greaterThan").removeClass("validate-greaterThan-blur");
       }
     },
     classRuleSettings : {
       required : {
         required : true
       },
       email : {
         email : true
       },
       url : {
         url : true
       },
       date : {
         date : true
       },
       dateISO : {
         dateISO : true
       },
       number : {
         number : true
       },
       digits : {
         digits : true
       },
       creditcard : {
         creditcard : true
       }
     },
     addClassRules : function(className, rules) {
       if (className.constructor === String) {
         this.classRuleSettings[className] = rules;
       } else {
         $.extend(this.classRuleSettings, className);
       }
     },
     classRules : function(element) {
       var t = {};
       var e = $(element).attr("class");
       return e && $.each(e.split(" "), function() {
         if (this in $.validator.classRuleSettings) {
           $.extend(t, $.validator.classRuleSettings[this]);
         }
       }), t;
     },
     normalizeAttributeRule : function(rules, type, method, value) {
       if (/min|max|step/.test(method) && (null === type || /number|range|text/.test(type))) {
         /** @type {number} */
         value = Number(value);
         if (isNaN(value)) {
           value = void 0;
         }
       }
       if (value || 0 === value) {
         /** @type {number} */
         rules[method] = value;
       } else {
         if (type === method && "range" !== type) {
           /** @type {boolean} */
           rules[method] = true;
         }
       }
     },
     attributeRules : function(element) {
       var method;
       var value;
       var rules = {};
       var f = $(element);
       var type = element.getAttribute("type");
       for (method in $.validator.methods) {
         if ("required" === method) {
           value = element.getAttribute(method);
           if ("" === value) {
             /** @type {boolean} */
             value = true;
           }
           /** @type {boolean} */
           value = !!value;
         } else {
           value = f.attr(method);
         }
         this.normalizeAttributeRule(rules, type, method, value);
       }
       return rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength) && delete rules.maxlength, rules;
     },
     dataRules : function(element) {
       var method;
       var value;
       var rules = {};
       var f = $(element);
       var type = element.getAttribute("type");
       for (method in $.validator.methods) {
         value = f.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());
         if ("" === value) {
           /** @type {boolean} */
           value = true;
         }
         this.normalizeAttributeRule(rules, type, method, value);
       }
       return rules;
     },
     staticRules : function(element) {
       var c = {};
       var validator = $.data(element.form, "validator");
       return validator.settings.rules && (c = $.validator.normalizeRule(validator.settings.rules[element.name]) || {}), c;
     },
     normalizeRules : function(rules, element) {
       return $.each(rules, function(languageCode, val) {
         if (val === false) {
           return void delete rules[languageCode];
         }
         if (val.param || val.depends) {
           /** @type {boolean} */
           var $elementsCovered = true;
           switch(typeof val.depends) {
             case "string":
               /** @type {boolean} */
               $elementsCovered = !!$(val.depends, element.form).length;
               break;
             case "function":
               $elementsCovered = val.depends.call(element, element);
           }
           if ($elementsCovered) {
             rules[languageCode] = void 0 === val.param || val.param;
           } else {
             $.data(element.form, "validator").resetElements($(element));
             delete rules[languageCode];
           }
         }
       }), $.each(rules, function(rule, parameter) {
         rules[rule] = $.isFunction(parameter) && "normalizer" !== rule ? parameter(element) : parameter;
       }), $.each(["minlength", "maxlength"], function() {
         if (rules[this]) {
           /** @type {number} */
           rules[this] = Number(rules[this]);
         }
       }), $.each(["rangelength", "range"], function() {
         var filem;
         if (rules[this]) {
           if ($.isArray(rules[this])) {
             /** @type {!Array} */
             rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
           } else {
             if ("string" == typeof rules[this]) {
               filem = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/);
               /** @type {!Array} */
               rules[this] = [Number(filem[0]), Number(filem[1])];
             }
           }
         }
       }), $.validator.autoCreateRanges && (null != rules.min && null != rules.max && (rules.range = [rules.min, rules.max], delete rules.min, delete rules.max), null != rules.minlength && null != rules.maxlength && (rules.rangelength = [rules.minlength, rules.maxlength], delete rules.minlength, delete rules.maxlength)), rules;
     },
     normalizeRule : function(data) {
       if ("string" == typeof data) {
         var pathOrData = {};
         $.each(data.split(/\s/), function() {
           /** @type {boolean} */
           pathOrData[this] = true;
         });
         data = pathOrData;
       }
       return data;
     },
     addMethod : function(name, method, message) {
       /** @type {!Function} */
       $.validator.methods[name] = method;
       $.validator.messages[name] = void 0 !== message ? message : $.validator.messages[name];
       if (method.length < 3) {
         $.validator.addClassRules(name, $.validator.normalizeRule(name));
       }
     },
     methods : {
       required : function(value, element, param) {
         if (!this.depend(param, element)) {
           return "dependency-mismatch";
         }
         if ("select" === element.nodeName.toLowerCase()) {
           var expRecords = $(element).val();
           return expRecords && expRecords.length > 0;
         }
         return this.checkable(element) ? this.getLength(value, element) > 0 : void 0 !== value && null !== value && value.length > 0;
       },
       email : function(value, element) {
         return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
       },
       url : function(value, element) {
         return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[\/?#]\S*)?$/i.test(value);
       },
       date : function() {
         /** @type {boolean} */
         var a = false;
         return function(mockDate, element) {
           return a || (a = true, this.settings.debug && window.console && console.warn("The `date` method is deprecated and will be removed in version '2.0.0'.\nPlease don't use it, since it relies on the Date constructor, which\nbehaves very differently across browsers and locales. Use `dateISO`\ninstead or one of the locale specific methods in `localizations/`\nand `additional-methods.js`.")), this.optional(element) || !/Invalid|NaN/.test((new Date(mockDate)).toString());
         };
       }(),
       dateISO : function(value, element) {
         return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
       },
       number : function(value, element) {
         return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
       },
       digits : function(value, element) {
         return this.optional(element) || /^\d+$/.test(value);
       },
       minlength : function(value, element, param) {
         var length = $.isArray(value) ? value.length : this.getLength(value, element);
         return this.optional(element) || length >= param;
       },
       maxlength : function(value, element, param) {
         var length = $.isArray(value) ? value.length : this.getLength(value, element);
         return this.optional(element) || length <= param;
       },
       rangelength : function(value, element, param) {
         var length = $.isArray(value) ? value.length : this.getLength(value, element);
         return this.optional(element) || length >= param[0] && length <= param[1];
       },
       min : function(value, element, param) {
         return this.optional(element) || value >= param;
       },
       max : function(value, element, param) {
         return this.optional(element) || value <= param;
       },
       range : function(a, m, b) {
         return this.optional(m) || a >= b[0] && a <= b[1];
       },
       step : function(value, element, param) {
         var decimals;
         var xml = $(element).attr("type");
         /** @type {string} */
         var lastErrorOutput = "Step attribute on input type " + xml + " is not supported.";
         /** @type {!Array} */
         var supportedTypes = ["text", "number", "range"];
         /** @type {!RegExp} */
         var negativeRegex = new RegExp("\\b" + xml + "\\b");
         var xmlemptyTag = xml && !negativeRegex.test(supportedTypes.join());
         /**
          * @param {string} num
          * @return {?}
          */
         var decimalPlaces = function(num) {
           /** @type {(Array<string>|null)} */
           var linebreaks = ("" + num).match(/(?:\.(\d+))?$/);
           return linebreaks && linebreaks[1] ? linebreaks[1].length : 0;
         };
         /**
          * @param {number} value
          * @return {?}
          */
         var toInt = function(value) {
           return Math.round(value * Math.pow(10, decimals));
         };
         /** @type {boolean} */
         var check = true;
         if (xmlemptyTag) {
           throw new Error(lastErrorOutput);
         }
         return decimals = decimalPlaces(param), (decimalPlaces(value) > decimals || toInt(value) % toInt(param) !== 0) && (check = false), this.optional(element) || check;
       },
       equalTo : function(param, value, rule) {
         var target = $(rule);
         return this.settings.onfocusout && target.not(".validate-equalTo-blur").length && target.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function() {
           $(value).valid();
         }), param === target.val();
       },
       remote : function(value, element, options, method) {
         if (this.optional(element)) {
           return "dependency-mismatch";
         }
         /** @type {string} */
         method = "string" == typeof method && method || "remote";
         var validator;
         var data;
         var optionDataString;
         var previous = this.previousValue(element, method);
         return this.settings.messages[element.name] || (this.settings.messages[element.name] = {}), previous.originalMessage = previous.originalMessage || this.settings.messages[element.name][method], this.settings.messages[element.name][method] = previous.message, options = "string" == typeof options && {
           url : options
         } || options, optionDataString = $.param($.extend({
           data : value
         }, options.data)), previous.old === optionDataString ? previous.valid : (previous.old = optionDataString, validator = this, this.startRequest(element), data = {}, data[element.name] = value, $.ajax($.extend(true, {
           mode : "abort",
           port : "validate" + element.name,
           dataType : "json",
           data : data,
           context : validator.currentForm,
           success : function(response) {
             var errors;
             var message;
             var submitted;
             /** @type {boolean} */
             var valid = response === true || "true" === response;
             validator.settings.messages[element.name][method] = previous.originalMessage;
             if (valid) {
               submitted = validator.formSubmitted;
               validator.resetInternals();
               validator.toHide = validator.errorsFor(element);
               validator.formSubmitted = submitted;
               validator.successList.push(element);
               /** @type {boolean} */
               validator.invalid[element.name] = false;
               validator.showErrors();
             } else {
               errors = {};
               message = response || validator.defaultMessage(element, {
                 method : method,
                 parameters : value
               });
               errors[element.name] = previous.message = message;
               /** @type {boolean} */
               validator.invalid[element.name] = true;
               validator.showErrors(errors);
             }
             /** @type {boolean} */
             previous.valid = valid;
             validator.stopRequest(element, valid);
           }
         }, options)), "pending");
       }
     }
   });
   var ajax;
   var pendingRequests = {};
   return $.ajaxPrefilter ? $.ajaxPrefilter(function(options, b, xhr) {
     var port = options.port;
     if ("abort" === options.mode) {
       if (pendingRequests[port]) {
         pendingRequests[port].abort();
       }
       pendingRequests[port] = xhr;
     }
   }) : (ajax = $.ajax, $.ajax = function(settings) {
     var mode = ("mode" in settings ? settings : $.ajaxSettings).mode;
     var port = ("port" in settings ? settings : $.ajaxSettings).port;
     return "abort" === mode ? (pendingRequests[port] && pendingRequests[port].abort(), pendingRequests[port] = ajax.apply(this, arguments), pendingRequests[port]) : ajax.apply(this, arguments);
   }), $;
 });
 